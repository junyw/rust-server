<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>carbon is a light weight asynchronous web server</title>
	</head>
<body>
<h1>carbon is a light weight asynchronous web server </h1>

<h2>Intro</h2>

<p>At its core, carbon utilize </p>

<p><a href="">kqueue() system call</a>(https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2) </p>

<p>from BSD kernel. Kqueue() system call provides a non-blocking channel for user </p>

<p>to be notified when any of the events in the k-queue happens or holds a condition. </p>

<h2>Implementation</h2>

<p>Architecture overview</p>

<pre><code>extern crate nix;
extern crate ansi_term;
extern crate regex;
extern crate chrono;
extern crate fnv;

pub mod io; 
pub mod http;
pub mod server;
pub mod service;
pub mod router;
pub mod view;
</code></pre>

<p>!<a href="">img</a>(assets/app<em>layout.png)
</em></p>

<p>Figure 1 is an overview of the Carbon, the main components are: </p>

<ul>
	<li>IO</li>
	<li>Router</li>
	<li>Server</li>
	<li>Service</li>
	<li>View</li>
</ul>

<h3>IO</h3>

<p><code>IO</code> implements two <code>modulos</code>: <code>Event</code> and <code>Notification</code>.</p>

<h4>Event is a vehicle for kevents </h4>

<pre><code>use nix::sys::event::{KEvent, EventFilter, FilterFlag};
use nix::sys::event::{EV_ADD, EV_ENABLE, EV_DELETE, EV_ERROR};
use std::os::unix::io::RawFd;

use io::notification::Identifier;
pub struct Event {
	pub kevent: KEvent,
}
impl Event {
	pub fn new(id: &amp;Identifier) -&gt; Event {} 
	pub fn new_from_kevent(kevent: KEvent) -&gt; Event {}
	pub fn get_data(&amp;self) -&gt; u32 {}
	pub fn is_readable(&amp;self) -&gt; bool {}		
	pub fn is_writable(&amp;self) -&gt; bool {}
	pub fn is_error(&amp;self) -&gt; bool {}
	pub fn is_hup(&amp;self)  {}
	pub fn ev_set_add(&amp;mut self) {}
	pub fn ev_set_write(&amp;mut self) {}
	pub fn ev_set_delete(&amp;mut self) {}
	fn new_kevent(id: &amp; RawFd) -&gt; KEvent {}
	pub fn new_timer_event(id: usize, timer: isize) -&gt; Event {}
}
</code></pre>

<h4>Notification provide an <code>EventLoop</code> and <code>Handler</code> to produce <code>Events</code> and perform Asynchronous request/response</h4>

<pre><code>pub trait Handler {
    fn ready(&amp;mut self, id:RawFd, ev_set : EventSet, event_loop : &amp;mut EventLoop);
}

pub struct EventLoop {
	kqueue: RawFd,
	// ev_list is used for retrival
	ev_list: Vec&lt;KEvent&gt;,
}
impl EventLoop {
	pub fn new() -&gt; io::Result&lt;EventLoop&gt; {}
	fn ev_register(&amp;self, event: Event) {}
	pub fn register(&amp;self, id: &amp;Identifier) {}
	pub fn reregister() {}
	pub fn deregister(&amp;self, id: &amp;Identifier) {}
	pub fn run&lt;H: Handler&gt;(&amp;mut self, handler: &amp;mut H) {}
	fn poll&lt;H: Handler&gt;(&amp;mut self, handler: &amp;mut H) {}
}

pub struct Identifier {
	fd: RawFd,
	filter: Interest,
}
impl Identifier {
	pub fn new(fd: RawFd, interest: Interest) -&gt; Identifier{}
	pub fn get_fd(&amp;self) -&gt; RawFd {}
	pub fn readable(&amp;self) -&gt; bool {}
	pub fn writable(&amp;self) -&gt; bool {}

pub enum Interest {
    Read,
    Write,
}
pub struct EventSet(usize, usize);
impl EventSet {
	pub fn new() -&gt; EventSet {}
	pub fn readable() -&gt; EventSet {}
	pub fn writable() -&gt; EventSet {}
	pub fn set_data(&amp;mut self, data :usize) {}
	pub fn get_data(&amp;self) -&gt; usize {}
	pub fn is_readable(&amp;self) -&gt; bool {}
	pub fn is_writable(&amp;self) -&gt; bool {}
}
 
</code></pre>

<h3>Router provides rules for handle request and query resources</h3>

<pre><code>pub struct RouterBuilder {
	regexs: Vec&lt;&amp;&#39;static str&gt;,
	methods: Vec&lt;Method&gt;,
	views: Vec&lt;Box&lt;View&gt;&gt;,
}
impl RouterBuilder {
	pub fn new() -&gt; RouterBuilder {}
	fn rule(self, method: Method, uri: &amp;&#39;static str, view: Box&lt;View&gt;) -&gt; RouterBuilder {}
	pub fn get(self, uri: &amp;&#39;static str, view: Box&lt;View&gt;) -&gt; RouterBuilder {}
	pub fn post(self, uri: &amp;&#39;static str, view: Box&lt;View&gt;) -&gt; RouterBuilder {}
	pub fn build(self) -&gt; Router {}
}

pub struct Router  {
	regexs: RegexSet,
	methods: Vec&lt;Method&gt;,
	views: Vec&lt;Box&lt;View&gt;&gt;,
	cache: FnvHashMap&lt;String, String&gt;,
}
impl Router {
	pub fn response(&amp;mut self, method: Method, path: &amp;str) -&gt; Response {
		}
	}
	fn route(&amp;self, method: Method, path: &amp;str) -&gt; Option&lt;usize&gt; {}
}
</code></pre>

<h3>Service provides a bootstrap <code>trait</code> <code>Service</code></h3>

<pre><code>pub trait Service {}

</code></pre>

<h3>View loads resources</h3>

<pre><code>pub trait View {
    fn render(&amp;self, cache: &amp;mut FnvHashMap&lt;String, String&gt;) -&gt; Response;
}

pub struct NotFound;
impl View for NotFound {
	fn render(&amp;self, cache: &amp;mut FnvHashMap&lt;String, String&gt;) -&gt; Response {}
}
pub struct Page {
	url: PathBuf,
}
impl Page {
	pub fn new(path: &amp;&#39;static str) -&gt; Page {}
}
impl View for Page {
	fn render(&amp;self, cache: &amp;mut FnvHashMap&lt;String, String&gt;) -&gt; Response {}
}
</code></pre>

<h3>Server binds connection ports and handles request</h3>

<pre><code>pub struct Server&lt;T: Service&gt; {
  event_loop: EventLoop,
  dispatcher: Dispatcher&lt;T&gt;,
} 

impl&lt;T: Service&gt; Server&lt;T&gt; {
  pub fn new(tcp: TcpListener, service: T) -&gt; Server&lt;T&gt; {
    Server {}
  }
  fn initialize(&amp;mut self) {}
  pub fn run(&amp;mut self) {}
}
pub struct Dispatcher&lt;T: Service&gt; {
  id: RawFd,
  listener: TcpListener,
  // callbacks?
  connections: FnvHashMap&lt;RawFd, Client&gt;,  // server needs to maintain a list of accepted connections
  service: T,
}

impl&lt;T: Service&gt;  Dispatcher&lt;T&gt; {
  pub fn new(tcp: TcpListener, service: T) -&gt; Dispatcher&lt;T&gt; {}
  pub fn as_raw_fd(&amp;self) -&gt; RawFd {}

  // Accept a new client connection.
  fn accept(&amp;mut self, event_loop: &amp;mut EventLoop) {}
  fn receive(&amp;mut self, id: RawFd, ev_set: EventSet, event_loop: &amp;mut EventLoop) {}
}

impl&lt;T: Service&gt; Handler for Dispatcher&lt;T&gt; {
    fn ready(&amp;mut self, id: RawFd, ev_set: EventSet, event_loop: &amp;mut EventLoop) {}
}
struct Client {
    socket: TcpStream,
    send_queue: Vec&lt;Message&gt;,
}

impl Client {
    pub fn new(sock: TcpStream) -&gt; Client {}
    pub fn peer_addr(&amp;self) -&gt; Option&lt;SocketAddr&gt; {}
    pub fn as_raw_fd(&amp;self) -&gt; RawFd {}
    pub fn get_message(&amp;mut self, len: &amp;u32) -&gt; Message {}
    pub fn send_message(&amp;mut self, message: Message) -&gt; () {}
    pub fn write_message(&amp;mut self) -&gt; () {}

#[derive(Clone, Debug)]
pub struct Message {
  pub buf: Vec&lt;u8&gt;,
}
impl Message {
  pub fn new() -&gt; Message {}

  pub fn length(&amp;self) -&gt; usize {}
  pub fn from_sock(&amp;mut self, sock: &amp;mut TcpStream, len: u32) {}
  pub fn to_str(&amp;self) -&gt; &amp;str {}
  pub fn print(&amp;self) {}
}

impl Write for Message {
   fn write(&amp;mut self, buf: &amp;[u8]) -&gt; io::Result&lt;usize&gt; {}
   fn flush(&amp;mut self) -&gt; io::Result&lt;()&gt; {}
}

</code></pre>

</body>
</html>

